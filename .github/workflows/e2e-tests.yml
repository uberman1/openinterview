name: E2E Tests

on:
  pull_request:
    branches: [ main, master, develop ]
  push:
    branches: [ main, master, develop ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci || npm install

      # If you later want to run the REAL app in CI, add a DATABASE_URL secret
      # and uncomment the next two lines:
      # - name: Configure DATABASE_URL (optional)
      #   run: echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV

      - name: Start mock server (no external deps)
        shell: bash
        run: |
          set -euo pipefail
          PORT=5000

          # If you set DATABASE_URL above and want to start your real app instead, replace the block below with:
          # (NODE_ENV=test PORT=$PORT npm start > server.log 2>&1 &)

          echo "Starting MOCK server on port $PORT"
          cat > mock-server.mjs <<'EOF'
          import http from 'node:http';
          import { parse as parseUrl } from 'node:url';

          const PORT = process.env.PORT || 5000;
          const MAX = 5, WINDOW = 60*60*1000;
          const buckets = new Map(), bookings = [];

          const json = (res, code, obj) => {
            const s = JSON.stringify(obj);
            res.writeHead(code, { 'content-type':'application/json' });
            res.end(s);
          };
          const parseBody = (req) => new Promise((resolve)=>{
            let d=''; req.on('data',c=>d+=c); req.on('end',()=>{ try{ resolve(JSON.parse(d||'{}')); }catch{ resolve({}); } });
          });
          const ensureAuth = (req,res) => {
            const h = req.headers['authorization'] || '';
            if (h === 'Bearer dev') return true;
            json(res,401,{error:'unauthorized'}); return false;
          };
          const rateLimit = (key) => {
            const now = Date.now();
            const arr = buckets.get(key) || [];
            while (arr.length && (now - arr[0]) > WINDOW) arr.shift();
            if (arr.length >= MAX) {
              const retryAfter = Math.ceil((WINDOW - (now - arr[0]))/1000);
              return { limited:true, retryAfter };
            }
            arr.push(now); buckets.set(key, arr); return { limited:false };
          };

          const server = http.createServer(async (req,res)=>{
            const { pathname } = parseUrl(req.url || '', true);

            if (req.method==='GET' && pathname==='/api/v1/scheduler/test')
              return json(res,200,{ ok:true });

            if (req.method==='POST' && pathname==='/api/v1/auth/login')
              return json(res,200,{ token:'dev' });

            if (req.method==='GET' && pathname==='/api/v1/scheduler/bookings') {
              if (!ensureAuth(req,res)) return;
              return json(res,200,{ bookings });
            }

            if (req.method==='POST' && pathname==='/api/v1/test/reset-rate-limit') {
              buckets.clear(); return json(res,200,{ ok:true });
            }

            if (req.method==='POST' && pathname==='/api/v1/scheduler/book') {
              const rl = rateLimit('book:'+(req.socket.remoteAddress||'unknown'));
              if (rl.limited) return json(res,429,{ error:'rate_limited', retryAfter: rl.retryAfter });
              const body = await parseBody(req);
              const { userId,startTimeUtc,endTimeUtc,name,email } = body || {};
              if (!userId || !startTimeUtc || !endTimeUtc || !name || !email)
                return json(res,400,{ error:'bad_request' });
              const dup = bookings.find(b=>b.userId===userId && b.startTimeUtc===startTimeUtc);
              if (dup) return json(res,409,{ error:'booking_conflict' });
              bookings.push({userId,startTimeUtc,endTimeUtc,name,email});
              return json(res,200,{ ok:true });
            }

            json(res,404,{ error:'not_found' });
          });

          server.listen(PORT, ()=> console.log('Mock server listening on', PORT));
          EOF

          (NODE_ENV=test PORT=$PORT node mock-server.mjs > server.log 2>&1 &)

          echo "--- initial diagnostics ---"
          sleep 1
          ps -ef | grep node || true
          tail -n 20 server.log || true

      - name: Wait for app to be ready
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for app to start on port 5000..."
          READY=""
          for i in {1..120}; do
            if curl -fsS "http://localhost:5000/api/v1/scheduler/test" >/dev/null 2>&1; then
              echo "TEST_BASE_URL=http://localhost:5000" >> $GITHUB_ENV
              READY=1; break
            fi
            if (( i % 10 == 0 )); then
              echo "[wait] $i/120 seconds elapsed"
              tail -n 5 server.log || true
            fi
            sleep 1
          done
          if [ -z "$READY" ]; then
            echo "App failed to start within 120 seconds"
            echo "---- server.log (tail) ----"
            tail -n 200 server.log || true
            exit 1
          fi

      - name: Run E2E tests (node:test)
        env:
          TEST_BASE_URL: ${{ env.TEST_BASE_URL }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Using TEST_BASE_URL=${TEST_BASE_URL}"
          if ls tests/*e2e*.mjs >/dev/null 2>&1; then
            node --test tests/*e2e*.mjs
          elif ls tests/*.e2e.test.mjs >/dev/null 2>&1; then
            node --test tests/*.e2e.test.mjs
          elif ls tests/*.mjs >/dev/null 2>&1; then
            node --test tests/*.mjs
          else
            echo "No E2E test files found under tests/"; exit 1
          fi

      - name: Upload server log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: server-log
          path: server.log
