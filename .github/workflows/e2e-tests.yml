name: E2E Tests

on:
  pull_request:
    branches: [ main, master, develop ]
  push:
    branches: [ main, master, develop ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci || npm install

      # If you have a CI database, uncomment these two lines:
      # - name: Configure DATABASE_URL (optional)
      #   run: echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> $GITHUB_ENV

      - name: Start server (real if DATABASE_URL set, else pure-node mock)
        shell: bash
        run: |
          set -euo pipefail
          PORT=5000

          if [ -n "${DATABASE_URL:-}" ]; then
            echo "Starting REAL server"
            (NODE_ENV=test PORT=$PORT npm start > server.log 2>&1 &)
          else
            echo "Starting MOCK server (no external deps)"
            rm -f mock-server.mjs
            printf '%s\n' \
"import http from 'node:http';" \
"import { parse as parseUrl } from 'node:url';" \
"" \
"const PORT = process.env.PORT || 5000;" \
"const MAX = 5; const WINDOW = 60*60*1000;" \
"const buckets = new Map(); const bookings = [];" \
"" \
"function json(res, code, obj){ const s = JSON.stringify(obj); res.writeHead(code,{ 'content-type':'application/json', 'content-length': Buffer.byteLength(s)}); res.end(s); }" \
"function notFound(res){ json(res,404,{error:'not_found'}); }" \
"function parseBody(req){ return new Promise((resolve)=>{ let d=''; req.on('data',c=>d+=c); req.on('end',()=>{ try{ resolve(JSON.parse(d||'{}')); }catch{ resolve({}); } }); }); }" \
"" \
"function ensureAuth(req, res){ const h=req.headers['authorization']||''; if(h==='Bearer dev') return true; json(res,401,{error:'unauthorized'}); return false; }" \
"function rateLimit(key){ const now=Date.now(); const arr=buckets.get(key)||[]; while(arr.length && (now-arr[0])>WINDOW) arr.shift(); if(arr.length>=MAX){ const retryAfter=Math.ceil((WINDOW-(now-arr[0]))/1000); return { limited:true, retryAfter }; } arr.push(now); buckets.set(key,arr); return { limited:false }; }" \
"" \
"const server = http.createServer(async (req,res)=>{" \
"  const { pathname } = parseUrl(req.url||'', true);" \
"  // health" \
"  if(req.method==='GET' && pathname==='/api/v1/scheduler/test'){ return json(res,200,{ok:true}); }" \
"" \
"  // login" \
"  if(req.method==='POST' && pathname==='/api/v1/auth/login'){ return json(res,200,{token:'dev'}); }" \
"" \
"  // bookings (protected)" \
"  if(req.method==='GET' && pathname==='/api/v1/scheduler/bookings'){ if(!ensureAuth(req,res)) return; return json(res,200,{bookings}); }" \
"" \
"  // reset rate limit" \
"  if(req.method==='POST' && pathname==='/api/v1/test/reset-rate-limit'){ buckets.clear(); return json(res,200,{ok:true}); }" \
"" \
"  // book (rate limited)" \
"  if(req.method==='POST' && pathname==='/api/v1/scheduler/book'){ const ip=(req.socket.remoteAddress||'unknown'); const { limited, retryAfter } = rateLimit('book:'+ip); if(limited) return json(res,429,{error:'rate_limited', retryAfter}); const body=await parseBody(req); const { userId,startTimeUtc,endTimeUtc,name,email } = body||{}; if(!userId||!startTimeUtc||!endTimeUtc||!name||!email) return json(res,400,{error:'bad_request'}); const dup=bookings.find(b=>b.userId===userId && b.startTimeUtc===startTimeUtc); if(dup) return json(res,409,{error:'booking_conflict'}); bookings.push({userId,startTimeUtc,endTimeUtc,name,email}); return json(res,200,{ok:true}); }" \
"" \
"  return notFound(res);" \
"});" \
"server.listen(PORT, ()=>{ console.log('Mock server listening on', PORT); });" \
            > mock-server.mjs
            (NODE_ENV=test PORT=$PORT node mock-server.mjs > server.log 2>&1 &)
          fi

          echo "Waiting for app to start on port 5000..."
          for i in {1..90}; do
            if curl -fsS http://localhost:5000/api/v1/scheduler/test >/dev/null 2>&1; then
              echo "TEST_BASE_URL=http://localhost:5000" >> $GITHUB_ENV
              READY=1; break
            fi
            sleep 1
            echo "Attempt $i/90: App not ready yet..."
          done
          if [ -z "${READY:-}" ]; then
            echo "App failed to start within 90 seconds"
            echo "---- server.log (tail) ----"; tail -n 200 server.log || true
            exit 1
          fi

      - name: Run E2E tests (node:test)
        env:
          TEST_BASE_URL: ${{ env.TEST_BASE_URL }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Using TEST_BASE_URL=${TEST_BASE_URL}"
          if ls tests/*e2e*.mjs >/dev/null 2>&1; then
            node --test tests/*e2e*.mjs
          elif ls tests/*.e2e.test.mjs >/dev/null 2>&1; then
            node --test tests/*.e2e.test.mjs
          elif ls tests/*.mjs >/dev/null 2>&1; then
            node --test tests/*.mjs
          else
            echo "No E2E test files found under tests/"; exit 1
          fi

      - name: Upload server log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: server-log
          path: server.log
